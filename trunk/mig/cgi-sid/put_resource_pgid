#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# --- BEGIN_HEADER ---
#
# put_resource_pgid - [insert a few words of module description on this line]
# Copyright (C) 2003-2009  The MiG Project lead by Brian Vinter
#
# This file is part of MiG.
#
# MiG is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# MiG is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# -- END_HEADER ---
#

# Martin Rehr Sep 2005

"""Let resources hand in their process group IDs used for managing
scripts running on the reources.
"""

import cgi
import os
import fcntl

# MiG imports

from shared.validstring import valid_dir_input
from shared.cgishared import init_cgiscript_possibly_with_cert
from shared.resadm import put_fe_pgid, put_exe_pgid

# ## Main ###

(logger, configuration, cert_name_no_spaces, o) = \
    init_cgiscript_possibly_with_cert()

if str(os.getenv('REQUEST_METHOD')) != 'GET':
    o.out('Please use HTTP GET')
    o.reply_and_exit(o.ERROR)

# Make sure that we're actually called by an authenticated resource!

if str(os.getenv('HTTPS')) != 'on':
    o.out('Please use HTTPS with session id (put_resource_pgid)!')
    o.reply_and_exit(o.ERROR)

# TODO: add session ID check here

remote_ip = str(os.getenv('REMOTE_ADDR'))

fieldstorage = cgi.FieldStorage()

res_type = fieldstorage.getfirst('type', '')
unique_resource_name = fieldstorage.getfirst('unique_resource_name', '')
pgid = fieldstorage.getfirst('pgid', '')
exe_name = fieldstorage.getfirst('exe_name', '')

# Please note that base_dir must end in slash to avoid access to other
# resource dirs when own name is a prefix of another resource name

base_dir = os.path.abspath(configuration.resource_home + os.sep
                            + unique_resource_name) + os.sep

# We do not have a trusted base dir here since there's no certificate data.
# Manually check input variables

if not valid_dir_input(configuration.resource_home,
                       unique_resource_name):

    # out of bounds - rogue resource!?!?

    o.out('invalid unique_resource_name! %s' % unique_resource_name)
    o.internal('put_resource_pgid FE called with illegal parameter(s) in what appears to be an illegal directory traversal attempt!: unique_resource_name %s, exe %s, cert_name_no_spaces %s'
                % (unique_resource_name, exe_name, cert_name_no_spaces))
    o.reply_and_exit(o.CLIENT_ERROR)

if not valid_dir_input(base_dir, 'EXE_' + exe_name + '.PGID'):

    # out of bounds - rogue resource!?!?

    o.out('invalid unique_resource_name / exe_name! %s / %s'
           % (unique_resource_name, exe_name))
    o.internal('put_resource_pgid EXE called with illegal parameter(s) in what appears to be an illegal directory traversal attempt!: unique_resource_name %s, exe %s, cert_name_no_spaces %s'
                % (unique_resource_name, exe_name, cert_name_no_spaces))
    o.reply_and_exit(o.CLIENT_ERROR)

if 'FE' == res_type:
    (status, msg) = put_fe_pgid(configuration.resource_home,
                                unique_resource_name, pgid)
    if status:
        msg += '(%s) (%s)' % (remote_ip, res_type)
elif 'EXE' == res_type:

    (status, msg) = put_exe_pgid(configuration.resource_home,
                                 unique_resource_name, exe_name, pgid,
                                 logger)
    if status:
        msg += '(%s) (%s)' % (remote_ip, res_type)

o.out(msg)
if status:
    o.reply_and_exit(o.OK)
else:
    o.reply_and_exit(o.CLIENT_ERROR)
