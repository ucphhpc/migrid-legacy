# This is the MiG specific apache configuration.
# It overrides some settings from the main configuration to be able to simply
# include this configuration from any 'vanilla' httpd.conf.
# Only tested with debian + apache 2.2+ but should work with others.

# Server name - comment out to just use hostname
<IfDefine BASE_FQDN>
ServerName ${BASE_FQDN}
</IfDefine>

# Point users in the right direction on errors
ServerAdmin __USER__

# We may need to run as MiG user or group for file access to work
# through CGI scripts and for direct user file access
__USER_CLAUSE__ __USER__
__GROUP_CLAUSE__ __GROUP__

# Performance Tuning
StartServers 5
# NOTE: increasing Serverlimit is required to exceed 256 workers
ServerLimit __APACHE_WORKER_PROCS__
# These two were renamed in apache 2.4
<IfVersion >= 2.4>
    MaxRequestWorkers __APACHE_WORKER_PROCS__
    MaxConnectionsPerChild 10000
</IfVersion>
<IfVersion < 2.4>
    MaxClients __APACHE_WORKER_PROCS__
    MaxRequestsPerChild 10000
</IfVersion>

# Do not allow TRACE requests, as recommended by OpenVAS scan results
TraceEnable off

# Default target for all directories not explicitly configured
<Directory "/">
    # Disable all overrides
    AllowOverride None
    # Enable FollowSymlinks and nothing else for all sub dirs
    Options FollowSymlinks
    # Deny all access to base mig dir and only allow on a subdir basis
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Deny from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all denied 
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Deny from all
    </IfVersion>
</Directory>
# Prevent .htaccess and .htpasswd files from being viewed by Web clients. 
# This may already be set in apache2.conf but better safe than sorry
<Files ~ "^\.ht">
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Deny from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all denied 
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Deny from all
    </IfVersion>
</Files>
# TODO: eliminate legacy /images and use /assets everywhere
# Public images shared by http and https pages and scripts
Alias /images/ "__MIG_CODE__/images/"
# Bind favicon once and for all
Alias /favicon.ico "__MIG_CODE__/images/skin/__SKIN__/favicon.ico"
<Directory "__MIG_CODE__/images">
    AuthType none
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Allow from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all granted 
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Allow from all
    </IfVersion>
</Directory>
# Public images, style and script shared by http and https pages and scripts
Alias /assets/ "__MIG_CODE__/assets/"
<Directory "__MIG_CODE__/assets">
    AuthType none
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Allow from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all granted 
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Allow from all
    </IfVersion>
</Directory>
# Other public data shared by http and https pages and scripts
Alias /public/ "__MIG_STATE__/wwwpublic/"
<Directory "__MIG_STATE__/wwwpublic">
    AuthType none
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Allow from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all granted 
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Allow from all
    </IfVersion>
</Directory>

# Prevent access to repository dot files to avoid semi-public information leak
<DirectoryMatch "^(__MIG_STATE__|__MIG_CODE__)/(.+/)?\.(cvs|svn|git|hg)">
    <IfVersion > 2.2>
        <IfModule mod_access_compat.c>
            Order allow,deny
            Deny from all
        </IfModule>
        <IfModule !mod_access_compat.c>
            Require all denied 
        </IfModule>
    </IfVersion>
    <IfVersion <= 2.2>
        Order allow,deny
        Deny from all
    </IfVersion>
</DirectoryMatch>

# Support relocatable configuration if possible
<IfModule mod_env.c>
    SetEnv MIG_CONF __MIG_CODE__/server/MiGserver.conf
</IfModule>

<IfModule mod_headers.c>
    # Set Content-Security-Policy to prevent iframe clickjacking as
    # recommended by W3C and security scans.
    Header always set Content-Security-Policy: "frame-ancestors 'self';"

    # Force IE browsers to exit compatibility mode even if enabled for all 
    # intranet sites, which is the standard policy in some places.
    <FilesMatch "(^$|\.(htm|html)$)">
        BrowserMatch MSIE ie
        Header set X-UA-Compatible "IE=Edge,chrome=1" env=ie
    </FilesMatch>
</IfModule>

# Configure WSGI if available
<IfModule mod_wsgi.c>
    # Run WSGI in daemon mode with multiprocessing-only for isolation.
    # Additional information in 'The mod_wsgi Daemon Processes' on:
    # http://code.google.com/p/modwsgi/wiki/ProcessesAndThreading
    #
    # We preserve the default WSGIApplicationGroup setting of '%{RESOURCE}'
    # to force every single application into a dedicated sub-interpreter
    # for complete isolation. This includes different VGrid Trac instances.
    # Please note that the processes number here is a FIXED cap on available 
    # worker processes so it strictly limits the number of concurrent clients.
    <IfDefine BASE_FQDN>
        WSGIDaemonProcess ${BASE_FQDN} processes=__WSGI_PROCS__ threads=1 display-name=%{GROUP} user=__USER__ group=__GROUP__ python-path=__MIG_CODE__  maximum-requests=1000
        WSGIProcessGroup ${BASE_FQDN}
    </IfDefine>
    # Make sure wsgi sockets are fully accessible to __USER__
    # NOTE: make sure SELinux or similar isn't interfering if apache still
    # gets permission errors on startup
    WSGISocketPrefix __MIG_CODE__/wsgi-bin/wsgi
</IfModule>

# Configure PUT script
<IfModule mod_actions.c>
    #
    # Action lets you define media types that will execute a script
    # whenever a matching file is called. This eliminates the need for
    # repeated URL pathnames for oft-used CGI file processors.
    # Format: Action media/type /cgi-script/location
    # Format: Action handler-name /cgi-script/location
    #
    # We need to let implicit put hit SID to allow resources and oneclick
    # Browser upload uses POST and migscripts use explict CERTPUT
    Script PUT /cgi-sid/put
    Script SIDPUT /cgi-sid/put
    Script CERTPUT /cgi-bin/put
</IfModule>

# Configure internal proxy support
<IfModule mod_proxy.c>
    # For security reasons we prevent Apache from acting like a forward proxy
    ProxyRequests Off
</IfModule>

# Configure SSL
# The whole SSL configuration in this context applies both to
# the main server and all SSL-enabled virtual hosts.
<IfModule mod_ssl.c>
    # These should only be explicitly set if not already set
    # elsewhere. This is the case with custom ports or with old
    # apache 1.3.x on Debian, so listen_prefix should be set to '#'
    # with apache 2.x when ports are already configured elsewhere.
    <IfDefine PUBLIC_FQDN>
    <IfDefine PUBLIC_PORT>
    __LISTEN_CLAUSE__ ${PUBLIC_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine PUBLIC_ALIAS_FQDN>
    <IfDefine PUBLIC_ALIAS_PORT>
    __PUBLIC_ALIAS_LISTEN__ ${PUBLIC_ALIAS_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine MIG_CERT_FQDN>
    <IfDefine MIG_CERT_PORT>
    __LISTEN_CLAUSE__ ${MIG_CERT_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine EXT_CERT_FQDN>
    <IfDefine EXT_CERT_PORT>
    __LISTEN_CLAUSE__ ${EXT_CERT_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine MIG_OID_FQDN>
    <IfDefine MIG_OID_PORT>
    __IF_SEPARATE_PORTS____LISTEN_CLAUSE__ ${MIG_OID_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine EXT_OID_FQDN>
    <IfDefine EXT_OID_PORT>
    __IF_SEPARATE_PORTS____LISTEN_CLAUSE__ ${EXT_OID_PORT}
    </IfDefine>
    </IfDefine>
    <IfDefine SID_FQDN>
    <IfDefine SID_PORT>
    __IF_SEPARATE_PORTS____LISTEN_CLAUSE__ ${SID_PORT}
    </IfDefine>
    </IfDefine>

    # Apache 2.4 changed SSL DN format - Force legacy format that we rely on
    <IfVersion >= 2.4>
        SSLOptions +LegacyDNStringFormat
    </IfVersion>

    # Some MIME-types for downloading Certificates and CRLs
    AddType application/x-x509-ca-cert .crt
    AddType application/x-pkcs7-crl .crl

    # Semaphore:
    #   Configure the path to the mutual exclusion semaphore the
    #   SSL engine uses internally for inter-process synchronization.
    # Changed from SSLMutex to just Mutex in apache>=2.4
    <IfVersion >= 2.4>
        Mutex sem
    </IfVersion>
    <IfVersion < 2.4>
        SSLMutex sem
    </IfVersion>

    # Inter-Process Session Cache:
    #   Configure the SSL Session Cache: First either `none'
    #   or `dbm:/path/to/file' for the mechanism to use and
    #   second the expiring timeout (in seconds).
    # Changed from shm to shmcb in apache 2.4
    <IfVersion >= 2.4>
        SSLSessionCache shmcb:__APACHE_RUN__/mod_ssl_scache
    </IfVersion>
    <IfVersion < 2.4>
        SSLSessionCache shm:__APACHE_RUN__/mod_ssl_scache
    </IfVersion>
    
    SSLSessionCacheTimeout 300

    # Pseudo Random Number Generator (PRNG):
    #   Configure one or more sources to seed the PRNG of the 
    #   SSL library. The seed data should be of good random quality.
    SSLRandomSeed startup file:/dev/urandom 1024
    SSLRandomSeed connect file:/dev/urandom 1024

    #   SSL Cipher Suite:
    #   List the ciphers that the client is permitted to negotiate.
    #   See the mod_ssl documentation for a complete list.
    SSLHonorCipherOrder On
    
    # IMPORTANT: these are *generated* hardened values based on generateconf
    # invocation. Any permanent changes need to be made there.
    SSLCipherSuite __APACHE_CIPHERS__
    SSLProxyCipherSuite __APACHE_CIPHERS__

    #   Server Certificate:
    #   Point SSLCertificateFile at a PEM encoded certificate.  If
    #   the certificate is encrypted, then you will be prompted for a
    #   pass phrase.  Note that a kill -HUP will prompt again. A test
    #   certificate can be generated with `make certificate' under
    #   built time. Keep in mind that if you've both a RSA and a DSA
    #   certificate you can configure both in parallel (to also allow
    #   the use of DSA ciphers, etc.)
    SSLCertificateFile __MIG_CERTS__/server.crt

    #   Server Private Key:
    #   If the key is not combined with the certificate, use this
    #   directive to point at the key file.  Keep in mind that if
    #   you've both a RSA and a DSA private key you can configure
    #   both in parallel (to also allow the use of DSA ciphers, etc.)
    SSLCertificateKeyFile __MIG_CERTS__/server.key

    #   Certificate Authority (CA):
    #   Set the CA certificate verification path where to find CA
    #   certificates for client authentication or alternatively one
    #   huge file containing all of them (file must be PEM encoded)
    #   Note: Inside SSLCACertificatePath you need hash symlinks
    #         to point to the certificate files. Use the provided
    #         Makefile to update the hash symlinks after changes.
    SSLCACertificateFile __MIG_CERTS__/cacert.pem

    #   Certificate Revocation Lists (CRL):
    #   Set the CA revocation path where to find CA CRLs for client
    #   authentication or alternatively one huge file containing all
    #   of them (file must be PEM encoded)
    #   Note: Inside SSLCARevocationPath you need hash symlinks
    #         to point to the certificate files. Use the provided
    #         Makefile to update the hash symlinks after changes.
    SSLCARevocationFile __MIG_CERTS__/crl.pem

    # Apache 2.4 defaults to not check CRL at all
    <IfVersion >= 2.4>
        SSLCARevocationCheck chain
    </IfVersion>

    #   SSL Protocol Adjustments:
    #   The safe and default but still SSL/TLS standard compliant shutdown
    #   approach is that mod_ssl sends the close notify alert but doesn't
    #   wait for the close notify alert from client. When you need a
    #   different shutdown approach you can use one of the following
    #   variables:
    #   o ssl-unclean-shutdown:
    #     This forces an unclean shutdown when the connection is closed, 
    #     i.e. no SSL close notify alert is send or allowed to received.
    #     This violates the SSL/TLS standard but is needed for some 
    #     brain-dead browsers. Use this when you receive I/O errors because
    #     of the standard approach where mod_ssl sends the close notify
    #     alert.
    #   o ssl-accurate-shutdown:
    #     This forces an accurate shutdown when the connection is closed, 
    #     i.e. a SSL close notify alert is send and mod_ssl waits for the
    #     close notify alert of the client. This is 100% SSL/TLS standard
    #     compliant, but in practice often causes hanging connections with
    #     brain-dead browsers. Use this only for browsers where you know
    #     that their SSL implementation works correctly. 
    #   Notice: Most problems of broken clients are also related to the
    #   HTTP keep-alive facility, so you usually additionally want to
    #   disable keep-alive for those clients, too. Use variable
    #   "nokeepalive" for this.
    #   Similarly, one has to force some clients to use HTTP/1.0 to
    #   workaround their broken HTTP/1.1 implementation. Use variables
    #   "downgrade-1.0" and "force-response-1.0" for this.
    #
    # NB: The default setting of degrading ALL IE versions to 1.0 and no
    # keepalive is way too harsh. Changed to only include the unclean shutdown
    # which is still there at least in IE 6-9
    #SetEnvIf User-Agent ".*MSIE.*" \
    #    nokeepalive ssl-unclean-shutdown \
    #    downgrade-1.0 force-response-1.0
    #SetEnvIf User-Agent ".*MSIE.*" \
    SetEnvIf User-Agent ".*MSIE [6-9].*" \
        ssl-unclean-shutdown

    # Disable old weak SSL implementations
    SSLProtocol All -SSLv2 -SSLv3
    SSLProxyProtocol All -SSLv2 -SSLv3

    # Prevent the CRIME attack vector completely
    # SSLCompression option requires apache 2.2.24+
    <IfVersion >= 2.4>
        SSLCompression off
    </IfVersion>
    <IfVersion < 2.4>
        # Fall back to backwards compatible Location method if not recent
        <Location />
            SetEnv no-gzip
        </Location>
    </IfVersion>

    # Use dhparams directly if available and apache is recent enough.
    # For slightly older versions of apache one can instead concatenate
    # the dhparams file into the server certificate file for the same effect.
    <If "-f '__MIG_CERTS__/dhparams.pem'">
        <IfVersion >= 2.4.8>
            SSLOpenSSLConfCmd DHParameters "__MIG_CERTS__/dhparams.pem"
        </IfVersion>
    </If>

</IfModule>

# Configure public access virtual host
<IfDefine PUBLIC_FQDN>
<IfDefine PUBLIC_PORT>
# NOTE: use either of these depending on your certificate authority setup.
# Basic setup with server certificate from external certificate authority.
__NOT_VERIFYCERTS_COMMENTED__ <VirtualHost ${PUBLIC_FQDN}:${PUBLIC_PORT}>
# For e.g. Letsencrypt server certificate with http verification of domains.
__IS_VERIFYCERTS_COMMENTED__ <VirtualHost *:${PUBLIC_PORT}>
    ServerName ${PUBLIC_FQDN}
    __IS_VERIFYCERTS_COMMENTED__ ServerAlias __BASE_FQDN__ __MIG_CERT_FQDN__ __EXT_CERT_FQDN__ __MIG_OID_FQDN__ __EXT_OID_FQDN__ __SID_FQDN__ __IO_FQDN__  
    <IfDefine PUBLIC_ALIAS_FQDN>
    <IfDefine PUBLIC_ALIAS_PORT>
    ServerAlias ${PUBLIC_ALIAS_FQDN}
    </IfDefine>
    </IfDefine>
    # Optionally add extra server aliases for current and future use here
    #ServerAlias something.__BASE_FQDN__ somethingelse.__BASE_FQDN__

    # General setup for the virtual host
    DocumentRoot "__MIG_STATE__/wwwpublic"
    ErrorLog __APACHE_LOG__/error.log
    CustomLog __APACHE_LOG__/access.log common

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog __APACHE_LOG__/rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Let all certificate validation requests on plain http through unaltered
    __IS_VERIFYCERTS_COMMENTED__RewriteCond %{HTTPS} off
    __IS_VERIFYCERTS_COMMENTED__RewriteCond %{REQUEST_URI} ^/.well-known/acme-challenge/
    __IS_VERIFYCERTS_COMMENTED__RewriteRule ^ - [L]

    # Redirect all remaining SID requests to HTTPS
    # Should apply in general and specifically works around Seafile avatar bug
    <IfDefine SID_FQDN>
        RewriteCond %{HTTPS} off
        RewriteCond %{HTTP_HOST} ^${SID_FQDN}$
        RewriteRule (.*) https://${SID_FQDN}/$1 [R,L]
    </IfDefine>

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public)/
    RewriteRule ^ - [L]

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/vgrid/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond __MIG_STATE__/vgrid_home/%1 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to public file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /vgrid/$1/$2 [L,R]
    
    ### All public vgrid component access is disabled to avoid abuse

    # Redirect to public vgrid components
    #RewriteCond %{REQUEST_URI} ^/vgridpublicscm
    #RewriteCond %{HTTP_REFERER} /wsgi-bin/
    #RewriteRule ^/vgridpublicscm/(.*) /vgrid/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    #RewriteCond %{REQUEST_URI} ^/vgridpublicscm
    #RewriteRule ^/vgridpublicscm/(.*) /vgrid/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    #RewriteCond %{REQUEST_URI} ^/vgridpublictracker
    #RewriteCond %{HTTP_REFERER} /wsgi-bin/
    #RewriteRule ^/vgridpublictracker/(.*) /vgrid/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    #RewriteCond %{REQUEST_URI} ^/vgridpublictracker
    #RewriteRule ^/vgridpublictracker/(.*) /vgrid/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # We need to let vgrid component Xgi requests pass through to
    # *ScriptAlias* handlers.
    #RewriteRule ^/vgrid/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /vgrid/$1/$2/$3/$4 [L,PT]

    # Public vgrid component scripts
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/cgi-bin/$3
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/wsgi-bin/$3
    </IfModule>
</VirtualHost>
</IfDefine>
</IfDefine>

# Configure SSL public alias virtual host(s)
<IfDefine PUBLIC_ALIAS_FQDN>
<IfDefine PUBLIC_ALIAS_PORT>
<VirtualHost ${PUBLIC_ALIAS_FQDN}:${PUBLIC_ALIAS_PORT}>
    ServerName ${PUBLIC_ALIAS_FQDN}
    # General setup for the virtual host
    DocumentRoot "/home/mig/state/wwwpublic"
    ErrorLog /var/log/httpd/ssl-error.log
    CustomLog /var/log/httpd/ssl-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    SSLCertificateFile /etc/httpd/MiG-certificates/${PUBLIC_ALIAS_FQDN}/server.crt
    SSLCertificateKeyFile /etc/httpd/MiG-certificates/${PUBLIC_ALIAS_FQDN}/server.key
    SSLCertificateChainFile /etc/httpd/MiG-certificates/${PUBLIC_ALIAS_FQDN}/server.ca.pem

    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog /var/log/httpd/rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Break rewriting chain for commonly-requested final destinations
    # * Internal Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public)/
    RewriteRule ^ - [L]
</VirtualHost>
</IfDefine>
</IfDefine>

# Configure SSL with certificates virtual host(s)
<IfDefine MIG_CERT_FQDN>
<IfDefine MIG_CERT_PORT>
# SSL with certificate from local CA
<VirtualHost ${MIG_CERT_FQDN}:${MIG_CERT_PORT}>
    # General setup for the virtual host
    ServerName ${MIG_CERT_FQDN}
    <IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    __SERVERALIAS_CLAUSE__ ${BASE_FQDN}
    </IfDefine>
    DocumentRoot "__MIG_STATE__/user_home"
    ErrorLog __APACHE_LOG__/ssl-cert-error.log
    CustomLog __APACHE_LOG__/ssl-cert-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    __VHOSTCERTS_COMMENTED__SSLCertificateFile __MIG_CERTS__/${MIG_CERT_FQDN}/server.crt
    __VHOSTCERTS_COMMENTED__SSLCertificateKeyFile __MIG_CERTS__/${MIG_CERT_FQDN}/server.key
    __VHOSTCERTS_COMMENTED__SSLCertificateChainFile __MIG_CERTS__/${MIG_CERT_FQDN}/server.ca.pem

    # Keep cgi-cert name for backwards compatibility but point it
    # to cgi-bin
    ScriptAlias /cgi-cert/ "__MIG_CODE__/cgi-bin/"
    ScriptAlias /cgi-bin/ "__MIG_CODE__/cgi-bin/"
    ScriptAlias /cgi-sid/ "__MIG_CODE__/cgi-sid/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        __HSTS_COMMENTED__Header always set Strict-Transport-Security "max-age=31536000"
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "__MIG_CODE__/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "__MIG_CODE__/software-repository/swrepo.py"
    </IfModule>
    
    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient require
    SSLVerifyDepth 10

    # Pass cert DN as REMOTE_USER env for symmetry with openid login
    SSLUserName SSL_CLIENT_S_DN

    # Remote Seafile, OpenID, etc. requires SSL proxy
    __PROXY_HTTPS_COMMENTED__ SSLProxyEngine on

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog __APACHE_LOG__/ssl-cert-rewrite.log
        RewriteLogLevel 0
    </IfVersion>
    
    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    __SEAFILE_COMMENTED__ RewriteCond %{REQUEST_URI} ^/seafile//.*$
    __SEAFILE_COMMENTED__ RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond __MIG_STATE__/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want the PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=DIKU/OU=NA/CN=Jonas Bardino/emailAddress=bardino@diku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=DIKU+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@diku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:__MIG_CODE__/server/chkuserroot.py

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Prepend certificate DN so that we can modify it further without PATH
    # interference.
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:ENV:SSL_CLIENT_S_DN} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) %{LA-U:ENV:SSL_CLIENT_S_DN}/cert_mangle/$1 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^(.*)\ (.*)/cert_mangle/(.*)$ $1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^(.*)/(.*)/cert_mangle/(.*)$ $1+$2/cert_mangle/$3 [N]

    # Keep replacing double backslash from utf8 chars in DN with actual char
    # E.g. to replace the 'oslash' letter on the form \\xC3\\xB8 with %C3%B8

    RewriteRule ^(.*)\\x(..)(.*)/cert_mangle/(.*)$ $1${unescape:%$2}$3/cert_mangle/$4 [N]

    # Finally remove certificate marker and unescape previously escaped path
    RewriteRule ^(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [N]

    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]
    
    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    <Directory "__MIG_CODE__/cgi-bin">
        SSLOptions +StdEnvVars
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "__MIG_CODE__/wsgi-bin">
        SSLOptions +StdEnvVars
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_CODE__/software-repository">
        SSLOptions +StdEnvVars
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_CODE__/cgi-sid">
        SSLOptions +StdEnvVars
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_STATE__/user_home">
        # User home base is used for a number of public images and
        # templates.
        # Require a valid signed certificate for access to home base
        # and to individual user sub directories.
        # Access to user home dirs is further limited in .htaccess
        # files there.
        # The next line is crucial for cert_redirect to work!!!
        SSLOptions +StdEnvVars +ExportCertData
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_STATE__/user_home/*/">
        # Enable cert based auth with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "__MIG_STATE__/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    <LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
        SSLUserName SSL_CLIENT_S_DN_Email
    </LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>


    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    __SEAFILE_REMOTE_COMMENTED__ Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    __SEAFILE_COMMENTED__ <LocationMatch ^/(seafile|seafmedia|seafhttp)>
    __SEAFILE_COMMENTED__     <IfVersion > 2.2>
    __SEAFILE_COMMENTED__         <IfModule mod_access_compat.c>
    __SEAFILE_COMMENTED__             Order allow,deny
    __SEAFILE_COMMENTED__             Allow from all
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__         <IfModule !mod_access_compat.c>
    __SEAFILE_COMMENTED__             Require all granted
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__     <IfVersion <= 2.2>
    __SEAFILE_COMMENTED__         Order allow,deny
    __SEAFILE_COMMENTED__         Allow from all
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__ </LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    __SEAFILE_COMMENTED__ ProxyPass /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ RewriteRule ^/seafhttp - [QSA,L]

    #
    # Seahub web interface
    #
    __SEAFILE_COMMENTED__ SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    __SEAFILE_COMMENTED__ ProxyPass /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPass /seafmedia __SEAFMEDIA_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPassReverse /seafmedia __SEAFMEDIA_PROXY_URL__

    #
    # JupyterHub server
    #
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    __PREVIEW_COMMENTED__ ProxyPass /paraview http://localhost:8080/paraview

    # This is the path of the mapping file
    __PREVIEW_COMMENTED__ RewriteMap session-to-port txt:__MIG_STATE__/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    __PREVIEW_COMMENTED__ RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    __PREVIEW_COMMENTED__ RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

</VirtualHost>
</IfDefine>
</IfDefine>

<IfDefine EXT_CERT_FQDN>
<IfDefine EXT_CERT_PORT>
# SSL with certificate from external CA that we trust
<VirtualHost ${EXT_CERT_FQDN}:${EXT_CERT_PORT}>
    # General setup for the virtual host
    ServerName ${EXT_CERT_FQDN}
    <IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    __SERVERALIAS_CLAUSE__ ${BASE_FQDN}
    </IfDefine>
    DocumentRoot "__MIG_STATE__/user_home"
    ErrorLog __APACHE_LOG__/ssl-cert-error.log
    CustomLog __APACHE_LOG__/ssl-cert-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    __VHOSTCERTS_COMMENTED__ SSLCertificateFile __MIG_CERTS__/${EXT_CERT_FQDN}/server.crt
    __VHOSTCERTS_COMMENTED__ SSLCertificateKeyFile __MIG_CERTS__/${EXT_CERT_FQDN}/server.key
    __VHOSTCERTS_COMMENTED__ SSLCertificateChainFile __MIG_CERTS__/${EXT_CERT_FQDN}/server.ca.pem

    # Keep cgi-cert name for backwards compatibility but point it
    # to cgi-bin
    ScriptAlias /cgi-cert/ "__MIG_CODE__/cgi-bin/"
    ScriptAlias /cgi-bin/ "__MIG_CODE__/cgi-bin/"
    ScriptAlias /cgi-sid/ "__MIG_CODE__/cgi-sid/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        __HSTS_COMMENTED__ Header always set Strict-Transport-Security "max-age=31536000"
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "__MIG_CODE__/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "__MIG_CODE__/software-repository/swrepo.py"
    </IfModule>
    
    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient require
    SSLVerifyDepth 10

    # Pass cert DN as REMOTE_USER env for symmetry with openid login
    SSLUserName SSL_CLIENT_S_DN

    # Remote Seafile, OpenID, etc. requires SSL proxy
    __PROXY_HTTPS_COMMENTED__ SSLProxyEngine on

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog __APACHE_LOG__/ssl-cert-rewrite.log
        RewriteLogLevel 0
    </IfVersion>
    
    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    __SEAFILE_COMMENTED__ RewriteCond %{REQUEST_URI} ^/seafile//.*$
    __SEAFILE_COMMENTED__ RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond __MIG_STATE__/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want the PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=DIKU/OU=NA/CN=Jonas Bardino/emailAddress=bardino@diku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=DIKU+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@diku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:__MIG_CODE__/server/chkuserroot.py

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Prepend certificate DN so that we can modify it further without PATH
    # interference.
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:ENV:SSL_CLIENT_S_DN} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) %{LA-U:ENV:SSL_CLIENT_S_DN}/cert_mangle/$1 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^(.*)\ (.*)/cert_mangle/(.*)$ $1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^(.*)/(.*)/cert_mangle/(.*)$ $1+$2/cert_mangle/$3 [N]

    # Keep replacing double backslash from utf8 chars in DN with actual char
    # E.g. to replace the 'oslash' letter on the form \\xC3\\xB8 with %C3%B8

    RewriteRule ^(.*)\\x(..)(.*)/cert_mangle/(.*)$ $1${unescape:%$2}$3/cert_mangle/$4 [N]

    # Finally remove certificate marker and unescape previously escaped path
    RewriteRule ^(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [N]
    
    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]
    
    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    <Directory "__MIG_CODE__/cgi-bin">
        SSLOptions +StdEnvVars
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "__MIG_CODE__/wsgi-bin">
        SSLOptions +StdEnvVars
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_CODE__/software-repository">
        SSLOptions +StdEnvVars
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_CODE__/cgi-sid">
        SSLOptions +StdEnvVars
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_STATE__/user_home">
        # User home base is used for a number of public images and
        # templates.
        # Require a valid signed certificate for access to home base
        # and to individual user sub directories.
        # Access to user home dirs is further limited in .htaccess
        # files there.
        # The next line is crucial for cert_redirect to work!!!
        SSLOptions +StdEnvVars +ExportCertData
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_STATE__/user_home/*/">
        # Enable cert based auth with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "__MIG_STATE__/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    <LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
        SSLUserName SSL_CLIENT_S_DN_Email
    </LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>


    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    __SEAFILE_REMOTE_COMMENTED__ Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    __SEAFILE_COMMENTED__ <LocationMatch ^/(seafile|seafmedia|seafhttp)>
    __SEAFILE_COMMENTED__     <IfVersion > 2.2>
    __SEAFILE_COMMENTED__         <IfModule mod_access_compat.c>
    __SEAFILE_COMMENTED__             Order allow,deny
    __SEAFILE_COMMENTED__             Allow from all
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__         <IfModule !mod_access_compat.c>
    __SEAFILE_COMMENTED__             Require all granted
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__     <IfVersion <= 2.2>
    __SEAFILE_COMMENTED__         Order allow,deny
    __SEAFILE_COMMENTED__         Allow from all
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__ </LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    __SEAFILE_COMMENTED__ ProxyPass /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    __SEAFILE_COMMENTED__ SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    __SEAFILE_COMMENTED__ ProxyPass /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPass /seafmedia __SEAFMEDIA_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPassReverse /seafmedia __SEAFMEDIA_PROXY_URL__

    #
    # JupyterHub server
    #
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    __PREVIEW_COMMENTED__ ProxyPass /paraview http://localhost:8080/paraview

    # This is the path of the mapping file
    __PREVIEW_COMMENTED__ RewriteMap session-to-port txt:__MIG_STATE__/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    __PREVIEW_COMMENTED__ RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    __PREVIEW_COMMENTED__ RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

</VirtualHost>
</IfDefine>
</IfDefine>


<IfModule mod_auth_openid.cpp>
# Configure SSL with openid virtual host(s) if enabled
<IfDefine MIG_OID_FQDN>
<IfDefine MIG_OID_PORT>
# SSL with OpenID access based on user login against local MiG user DB
<VirtualHost ${MIG_OID_FQDN}:${MIG_OID_PORT}>
    # General setup for the virtual host
    ServerName ${MIG_OID_FQDN}
    <IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    __SERVERALIAS_CLAUSE__ ${BASE_FQDN}
    </IfDefine>
    DocumentRoot "__MIG_STATE__/user_home"
    ErrorLog __APACHE_LOG__/ssl-oid-error.log
    CustomLog __APACHE_LOG__/ssl-oid-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    __VHOSTCERTS_COMMENTED__ SSLCertificateFile __MIG_CERTS__/${MIG_OID_FQDN}/server.crt
    __VHOSTCERTS_COMMENTED__ SSLCertificateKeyFile __MIG_CERTS__/${MIG_OID_FQDN}/server.key
    __VHOSTCERTS_COMMENTED__ SSLCertificateChainFile __MIG_CERTS__/${MIG_OID_FQDN}/server.ca.pem

    # OpenID-based access to cgi-bin (see below)
    ScriptAlias /cgi-oid/ "__MIG_CODE__/cgi-bin/"
    ScriptAlias /cgi-bin/ "__MIG_CODE__/cgi-bin/"
    ScriptAlias /cgi-sid/ "__MIG_CODE__/cgi-sid/"

    # 2FA helper
    __TWOFACTOR_COMMENTED__ ScriptAlias /cgi-auth/ "/home/mig/mig/cgi-auth/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        __HSTS_COMMENTED__ Header always set Strict-Transport-Security "max-age=31536000"
        # OpenID 2.0's relying party verification mechanism needs this header
        # Use cgi-sid script if available, and fall back to a static file
        <IfDefine SID_FQDN>
            Header always set X-XRDS-Location "https://${SID_FQDN}:${SID_PORT}/cgi-sid/oiddiscover.py"
        </IfDefine>
        <IfDefine !SID_FQDN>
            <IfDefine BASE_FQDN>
                # NOTE: the contents of this static file can be generated with:
                # cd ~/mig && python shared/httpsclient.py | \
                #   grep -A 80 "xml version" > ~/state/wwwpublic/oiddiscover.xml
                Header always set X-XRDS-Location "https://${BASE_FQDN}/public/oiddiscover.xml"
            </IfDefine>
        </IfDefine>
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "__MIG_CODE__/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "__MIG_CODE__/software-repository/swrepo.py"
    </IfModule>
    
    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Transfer raw OpenID username to new MIG_OID_USERNAME env for use in
    # rewrites and htaccess
    SetEnvIf %{LU-A:REMOTE_USER} ^.*/([^/]+)$ MIG_OID_USERNAME="$1"

    # Remote Seafile, OpenID, etc. requires SSL proxy
    __PROXY_HTTPS_COMMENTED__ SSLProxyEngine on

    ### Any special directories without openid requirement should go here...

    # Currently no such dirs except the globally configured ones at the top


    #### All other locations share basic OpenID conf and can use SSL envs

    <LocationMatch .* >
        # Where to store OpenID user session DB - must be read/write
        # to web server user (__USER__)
        # Use custom location since some distros do not allow r/w in
        # apache run dir causing mod auth openid to segfault :-(
        AuthOpenIDDBLocation __MIG_STATE__/openid_store/__MIG_OID_AUTH_DB__
        AuthOpenIDSecureCookie On
        # Default to 12 hours of access without re-login
        AuthOpenIDCookieLifespan 43200
        # We only use login page for user friendly OpenID error handling.
        # Fall back to static entry page if SID is disabled.
        <IfDefine SID_FQDN>
            AuthOpenIDLoginPage https://${SID_FQDN}:${SID_PORT}/cgi-sid/login.py
        </IfDefine>
        <IfDefine !SID_FQDN>
            <IfDefine BASE_FQDN>
                AuthOpenIDLoginPage https://${BASE_FQDN}/public/
            </IfDefine>
        </IfDefine>
        # Require auth by our own OpenID server and use the base URL
        # in order to have manual user ID selection
        AuthOpenIDSingleIdP __MIG_OID_PROVIDER_BASE__
        # Single-sign-on by forcing trust root and cookie path to server base
        AuthOpenIDTrustRoot https://${MIG_OID_FQDN}/
        AuthOpenIDCookiePath /
    </LocationMatch>

    <Directory "__MIG_BASE__/">
        # Pass SSL variables on
        SSLOptions +StdEnvVars
    </Directory>

    # Jupyter OpenID auth
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-openid.conf

    ### The rest are sub-dirs that inherit the general conf above and
    ### they can override any settings explicitly

    <Directory "__MIG_CODE__/cgi-bin">
        Options +ExecCGI
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted 
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "__MIG_CODE__/wsgi-bin">
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted 
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_STATE__/user_home/">
        # Require a valid OpenID login for access to user home and all user
        # sub directories.
        AuthType OpenID
        require valid-user
        # Access to user home dirs is also further limited in .htaccess
        # files there.
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted 
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_STATE__/user_home/*/">
        # Add additional auth restrictions with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "__MIG_STATE__/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>
    <LocationMatch "^/(index.html)?$">
        # Grant full access to landing page in user_home so that openid relying
        # party verification can work from index.html without an openid loop. 
        # The access restriction is there on individual user sub directories.
        # In apache-2.2 we must use Satisfy any and in 2.4 Require all granted
        # rather than Authtype None here.
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Satisfy Any
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Satisfy Any
        </IfVersion>
    </LocationMatch>
    # We allow access to cgi-sid with auth here just like for the cert case
    <Directory "__MIG_CODE__/cgi-sid">
        Options +ExecCGI
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted 
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # TODO: update to use OpenID email as username here?
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    #<LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
    #    SSLUserName SSL_CLIENT_S_DN_Email
    #</LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog __APACHE_LOG__/ssl-oid-rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    __SEAFILE_COMMENTED__ RewriteCond %{REQUEST_URI} ^/seafile//.*$
    __SEAFILE_COMMENTED__ RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Filter OpenID SReg noise from query string
    RewriteCond %{QUERY_STRING} ^openid.ns.sreg=http%3A%2F%2Fopenid.net%2Fextensions%2Fsreg%2F1.1$
    RewriteRule ^(.*) $1? [L,R]

    # Common destinations without explicit auth or rewrite requirements 
    # NOTE: OpenID server might need to check cgi-sid/* and root address
    # NOTE: autocreate must be kept out of 2FA to work
    RewriteCond %{REQUEST_URI} ^/(favicon.ico|)$ [OR]
    RewriteCond %{REQUEST_URI} ^/(wsgi|cgi)-bin/autocreate.py$ [OR]
    RewriteCond %{REQUEST_URI} ^/(wsgi|cgi)-bin/autologout.py$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|openid|cgi-sid)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # 2FA helpers based on our own 2FA helper in mig/cgi-auth/twofactor.py
    #
    # We add the QSA flag to have apache automatically append the query.
    __TWOFACTOR_COMMENTED__ RewriteCond %{REQUEST_URI} !^__TWOFACTOR_PAGE__
    __TWOFACTOR_COMMENTED__ RewriteCond %{HTTP_COOKIE} !^.*2FA_Auth=[a-zA-Z0-9]+ [OR]
    __TWOFACTOR_COMMENTED__ RewriteCond %{HTTP_COOKIE} ^.*2FA_Auth=([a-zA-Z0-9]+) 
    __TWOFACTOR_STRICT_ADDRESS_COMMENTED__ RewriteCond /home/mig/state/twofactor_home/%{REMOTE_ADDR}_%1 !-l [OR]
    __TWOFACTOR_COMMENTED__ RewriteCond __MIG_STATE__/twofactor_home/%1 !-f
    __TWOFACTOR_COMMENTED__ RewriteRule ^(.*)$ __TWOFACTOR_PAGE__?redirect_url=$1 [QSA,L,R=302]

    # Now any 2FA is done so we proceed to scripting targets
    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-cert)/
    RewriteRule ^ - [L]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]


    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond __MIG_STATE__/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want /cert_redirect/PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=NBI/OU=NA/CN=Jonas Bardino/emailAddress=bardino@nbi.ku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=NBI+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@nbi.ku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:__MIG_CODE__/server/chkuserroot.py

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Fake certificate DN so that we can modify it further without PATH
    # interference. It may already be on final format but that doesn't hurt.
    # REMOTE_USER is only available in later stages so we must use 
    # LA-U:REMOTE_USER and it contains the full OpenID URL so we strip the
    # leading prefix until after the https://a.b.c/openid/id/ part.
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:REMOTE_USER} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) /strip_provider/%{LA-U:REMOTE_USER}/cert_mangle/$1 [NE,C]
    RewriteRule ^/strip_provider/__MIG_OID_PROVIDER_ID__/*(.+)/cert_mangle/(.*) $1/cert_mangle/$2 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^(.*)\ (.*)/cert_mangle/(.*)$ $1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^(.*)/(.*)/cert_mangle/(.*)$ $1+$2/cert_mangle/$3 [N]

    # Finally remove certificate marker and unescape previously escaped path
    # IMPORTANT: all major browsers have trouble to some extent when accessing
    # the resulting cert_redirect data if we let the rules proceed as in the
    # cert case ([N]). This leads to subtle errors like IE and Chrome returning
    # an error instead of downloading e.g. PDF files when double clicking in
    # Files and FF not actually applying Settings -> style. Strangely enough
    # FF succeeds in the former and Chrome+IE in the latter case.
    # We explicitly SSL proxy ([P]) to work around the issues.

    # NOTE: we proxy here to make sure we only target cert mangled paths.
    # It does NOT mean that we skip chroot check below as that will still
    # happen in the new request caused by the proxy'ing.
    RewriteRule ^(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [P]

    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]
    
    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>


    # Proxy forward /openid/ to grid_openid daemon running on ${IO_FQDN}
    # IMPORTANT: edit ProxyPass port if you edit openid port in MiGserver.conf
    <IfDefine IO_FQDN>
    __MIG_OID_PROXY_COMMENTED__ <Location /openid/>
    __MIG_OID_PROXY_COMMENTED__     <IfVersion > 2.2>
    __MIG_OID_PROXY_COMMENTED__         <IfModule mod_access_compat.c>
    __MIG_OID_PROXY_COMMENTED__             Order allow,deny
    __MIG_OID_PROXY_COMMENTED__             Allow from all
    __MIG_OID_PROXY_COMMENTED__         </IfModule>
    __MIG_OID_PROXY_COMMENTED__         <IfModule !mod_access_compat.c>
    __MIG_OID_PROXY_COMMENTED__             Require all granted
    __MIG_OID_PROXY_COMMENTED__         </IfModule>
    __MIG_OID_PROXY_COMMENTED__     </IfVersion>
    __MIG_OID_PROXY_COMMENTED__     <IfVersion <= 2.2>
    __MIG_OID_PROXY_COMMENTED__         Order allow,deny
    __MIG_OID_PROXY_COMMENTED__         Allow from all
    __MIG_OID_PROXY_COMMENTED__     </IfVersion>
    __MIG_OID_PROXY_COMMENTED__ </Location>
    __MIG_OID_PROXY_COMMENTED__ ProxyPass /openid/ https://${IO_FQDN}:__OPENID_PORT__/openid/
    __MIG_OID_PROXY_COMMENTED__ ProxyPassReverse /openid/ https://${IO_FQDN}:__OPENID_PORT__/openid/
    </IfDefine>

    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    __SEAFILE_REMOTE_COMMENTED__ Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    __SEAFILE_COMMENTED__ <LocationMatch ^/(seafile|seafmedia|seafhttp)>
    __SEAFILE_COMMENTED__     <IfVersion > 2.2>
    __SEAFILE_COMMENTED__         <IfModule mod_access_compat.c>
    __SEAFILE_COMMENTED__             Order allow,deny
    __SEAFILE_COMMENTED__             Allow from all
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__         <IfModule !mod_access_compat.c>
    __SEAFILE_COMMENTED__             Require all granted
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__     <IfVersion <= 2.2>
    __SEAFILE_COMMENTED__         Order allow,deny
    __SEAFILE_COMMENTED__         Allow from all
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__ </LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    __SEAFILE_COMMENTED__ ProxyPass /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    __SEAFILE_COMMENTED__ SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    __SEAFILE_COMMENTED__ ProxyPass /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPass /seafmedia __SEAFMEDIA_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPassReverse /seafmedia __SEAFMEDIA_PROXY_URL__

    #
    # JupyterHub server
    #
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    __PREVIEW_COMMENTED__ ProxyPass /paraview http://localhost:8081/paraview

    # This is the path of the mapping file
    __PREVIEW_COMMENTED__ RewriteMap session-to-port txt:__MIG_STATE__/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    __PREVIEW_COMMENTED__ RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    __PREVIEW_COMMENTED__ RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

    __TWOFACTOR_COMMENTED__ <Directory /home/mig/mig/cgi-auth>
    __TWOFACTOR_COMMENTED__     AuthType OpenID
    __TWOFACTOR_COMMENTED__     <IfVersion > 2.2>
    __TWOFACTOR_COMMENTED__         <IfModule mod_access_compat.c>
    __TWOFACTOR_COMMENTED__             Order allow,deny
    __TWOFACTOR_COMMENTED__             Allow from all
    __TWOFACTOR_COMMENTED__         </IfModule>
    __TWOFACTOR_COMMENTED__         # NOTE: no entry for 2.4+ here since it disables auth
    __TWOFACTOR_COMMENTED__         #<IfModule !mod_access_compat.c>
    __TWOFACTOR_COMMENTED__         #    Require all granted 
    __TWOFACTOR_COMMENTED__         #</IfModule>
    __TWOFACTOR_COMMENTED__     </IfVersion>
    __TWOFACTOR_COMMENTED__     <IfVersion <= 2.2>
    __TWOFACTOR_COMMENTED__         Order allow,deny
    __TWOFACTOR_COMMENTED__         Allow from all
    __TWOFACTOR_COMMENTED__     </IfVersion>
    __TWOFACTOR_COMMENTED__     Require valid-user
    __TWOFACTOR_COMMENTED__ </Directory>

</VirtualHost>
</IfDefine>
</IfDefine>

<IfDefine EXT_OID_FQDN>
<IfDefine EXT_OID_PORT>
# SSL with OpenID access based on user login against external user DB
<VirtualHost ${EXT_OID_FQDN}:${EXT_OID_PORT}>
    # General setup for the virtual host
    ServerName ${EXT_OID_FQDN}
    #<IfDefine BASE_FQDN>
    # Enable the next line if you want common aliasing for public address
    #__SERVERALIAS_CLAUSE__ ${BASE_FQDN}
    #</IfDefine>
    DocumentRoot "__MIG_STATE__/user_home"
    ErrorLog __APACHE_LOG__/ssl-oid-error.log
    CustomLog __APACHE_LOG__/ssl-oid-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    __VHOSTCERTS_COMMENTED__ SSLCertificateFile __MIG_CERTS__/${EXT_OID_FQDN}/server.crt
    __VHOSTCERTS_COMMENTED__ SSLCertificateKeyFile __MIG_CERTS__/${EXT_OID_FQDN}/server.key
    __VHOSTCERTS_COMMENTED__ SSLCertificateChainFile __MIG_CERTS__/${EXT_OID_FQDN}/server.ca.pem

    # OpenID-based access to cgi-bin (see below)
    ScriptAlias /cgi-oid/ "__MIG_CODE__/cgi-bin/"
    ScriptAlias /cgi-bin/ "__MIG_CODE__/cgi-bin/"
    ScriptAlias /cgi-sid/ "__MIG_CODE__/cgi-sid/"

    # 2FA helper
    __TWOFACTOR_COMMENTED__ ScriptAlias /cgi-auth/ "/home/mig/mig/cgi-auth/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        __HSTS_COMMENTED__ Header always set Strict-Transport-Security "max-age=31536000"
        # OpenID 2.0's relying party verification mechanism needs this header
        # Use cgi-sid script if available, and fall back to a static file
        <IfDefine SID_FQDN>
            Header always set X-XRDS-Location "https://${SID_FQDN}:${SID_PORT}/cgi-sid/oiddiscover.py"
        </IfDefine>
        <IfDefine !SID_FQDN>
            <IfDefine BASE_FQDN>
                # NOTE: the contents of this static file can be generated with:
                # cd ~/mig && python shared/httpsclient.py | \
                #   grep -A 80 "xml version" > ~/state/wwwpublic/oiddiscover.xml
                Header always set X-XRDS-Location "https://${BASE_FQDN}/public/oiddiscover.xml"
            </IfDefine>
        </IfDefine>
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "__MIG_CODE__/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "__MIG_CODE__/software-repository/swrepo.py"
    </IfModule>
    
    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Transfer raw OpenID username to new EXT_OID_USERNAME env for use in
    # rewrites and htaccess
    SetEnvIf %{LU-A:REMOTE_USER} ^.*/([^/]+)$ EXT_OID_USERNAME="$1"

    # Remote Seafile, OpenID, etc. requires SSL proxy
    __PROXY_HTTPS_COMMENTED__ SSLProxyEngine on

    ### Any special directories without openid requirement should go here...

    # Currently no such dirs except the globally configured ones at the top


    #### All other locations share basic OpenID conf and can use SSL envs

    <LocationMatch .* >
        # Where to store OpenID user session DB - must be read/write
        # to web server user (__USER__)
        # Use custom location since some distros do not allow r/w in
        # apache run dir causing mod auth openid to segfault :-(
        AuthOpenIDDBLocation __MIG_STATE__/openid_store/__EXT_OID_AUTH_DB__
        AuthOpenIDSecureCookie On
        # Default to 12 hours of access without re-login
        AuthOpenIDCookieLifespan 43200
        # We only use login page for user friendly OpenID error handling.
        # Fall back to static entry page if SID is disabled.
        <IfDefine SID_FQDN>
            AuthOpenIDLoginPage https://${SID_FQDN}:${SID_PORT}/cgi-sid/login.py
        </IfDefine>
        <IfDefine !SID_FQDN>
            <IfDefine BASE_FQDN>
                AuthOpenIDLoginPage https://${BASE_FQDN}/public/
            </IfDefine>
        </IfDefine>
        # Require auth by our own OpenID server and use the base URL
        # in order to have manual user ID selection
        AuthOpenIDSingleIdP __EXT_OID_PROVIDER_BASE__
        # Single-sign-on by forcing trust root and cookie path to server base
        AuthOpenIDTrustRoot https://${EXT_OID_FQDN}/
        AuthOpenIDCookiePath /
    </LocationMatch>

    <Directory "__MIG_BASE__/">
        # Pass SSL variables on
        SSLOptions +StdEnvVars
    </Directory>

    # Jupyter OpenID auth
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-openid.conf

    ### The rest are sub-dirs that inherit the general conf above and
    ### they can override any settings explicitly

    <Directory "__MIG_CODE__/cgi-bin">
        Options +ExecCGI
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted 
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "__MIG_CODE__/wsgi-bin">
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted 
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_STATE__/user_home/">
        # Require a valid OpenID login for access to user home and all user
        # sub directories.
        AuthType OpenID
        require valid-user
        # Access to user home dirs is also further limited in .htaccess
        # files there.
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted 
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_STATE__/user_home/*/">
        # Add additional auth restrictions with .htaccess file
        AllowOverride AuthConfig
    </Directory>
    <Directory "__MIG_STATE__/user_home/*/*/">
        # Do not allow or waste time on any nested htaccess files
        AllowOverride None
    </Directory>
    <LocationMatch "^/(index.html)?$">
        # Grant full access to landing page in user_home so that openid relying
        # party verification can work from index.html without an openid loop. 
        # The access restriction is there on individual user sub directories.
        # In apache-2.2 we must use Satisfy any and in 2.4 Require all granted
        # rather than Authtype None here.
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Satisfy Any
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Satisfy Any
        </IfVersion>
    </LocationMatch>
    # We allow access to cgi-sid with auth here just like for the cert case
    <Directory "__MIG_CODE__/cgi-sid">
        Options +ExecCGI
        AuthType OpenID
        require valid-user
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            # NOTE: no entry for 2.4+ here since it disables auth
            #<IfModule !mod_access_compat.c>
            #    Require all granted 
            #</IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>

    # BEGIN OPTIONAL MiG VGrid TRAC PROJECT TRACKER
    #
    # TODO: update to use OpenID email as username here?
    #
    # Use email from certificate DN for semi-automatic Trac login:
    # http://trac.edgewall.org/wiki/TracClientCertificates
    # We use email because we want it to be short and unique, but any field
    # on http://httpd.apache.org/docs/current/mod/mod_ssl.html should work.
    # Changes here requires sync with the trac_id_field MiG conf option.
    #
    # Common mappings from Apache to MiG conf:
    # SSL_CLIENT_S_DN -> distinguished_name
    # SSL_CLIENT_S_DN_Email -> email
    # SSL_CLIENT_S_DN_CN -> full_name
    # SSL_CLIENT_S_DN_O -> organization
    #<LocationMatch /[^/]+gi-bin/trac.[^/]+gi>
    #    SSLUserName SSL_CLIENT_S_DN_Email
    #</LocationMatch>
    # END OPTIONAL MiG VGrid TRAC PROJECT TRACKER

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog __APACHE_LOG__/ssl-oid-rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    __SEAFILE_COMMENTED__ RewriteCond %{REQUEST_URI} ^/seafile//.*$
    __SEAFILE_COMMENTED__ RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Filter OpenID SReg noise from query string
    RewriteCond %{QUERY_STRING} ^openid.ns.sreg=http%3A%2F%2Fopenid.net%2Fextensions%2Fsreg%2F1.1$
    RewriteRule ^(.*) $1? [L,R]

    # Common destinations without explicit auth or rewrite requirements
    # NOTE: OpenID server might need to check cgi-sid/* and root address
    # NOTE: autocreate must be kept out of 2FA to work
    RewriteCond %{REQUEST_URI} ^/(favicon.ico|)$ [OR]
    RewriteCond %{REQUEST_URI} ^/(wsgi|cgi)-bin/autocreate.py$ [OR]
    RewriteCond %{REQUEST_URI} ^/(wsgi|cgi)-bin/autologout.py$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public|openid|cgi-sid)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # 2FA helpers based on our own 2FA helper in mig/cgi-auth/twofactor.py
    #
    # We add the QSA flag to have apache automatically append the query.
    __TWOFACTOR_COMMENTED__ RewriteCond %{REQUEST_URI} !^__TWOFACTOR_PAGE__
    __TWOFACTOR_COMMENTED__ RewriteCond %{HTTP_COOKIE} !^.*2FA_Auth=[a-zA-Z0-9]+ [OR]
    __TWOFACTOR_COMMENTED__ RewriteCond %{HTTP_COOKIE} ^.*2FA_Auth=([a-zA-Z0-9]+) 
    __TWOFACTOR_STRICT_ADDRESS_COMMENTED__ RewriteCond /home/mig/state/twofactor_home/%{REMOTE_ADDR}_%1 !-l [OR]
    __TWOFACTOR_COMMENTED__ RewriteCond __MIG_STATE__/twofactor_home/%1 !-f
    __TWOFACTOR_COMMENTED__ RewriteRule ^(.*)$ __TWOFACTOR_PAGE__?redirect_url=$1 [QSA,L,R=302]

    # Now any 2FA is done so we proceed to scripting targets
    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-cert)/
    RewriteRule ^ - [L]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]


    # Setup jupyter forward user header
    # Important, don't allow lookahead to make internal subrequests
    # In addition if a jupyter request -> don't do more rewriting
    # beyond this point
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-rewrite.conf

    ### VGrid access: Preserve WSGI sessions but fall back to CGI.

    ### Important security guard
    # Catch and reject attempts to execute arbitrary code with a fake vgrid
    # component, using e.g. a custom hgweb.Xgi script manually saved in
    # REALVGRID/mysub/.vgridscm/Xgi-bin/hgweb.Xgi where mysub is an ordinary
    # dir in the VGrid shared REALVGRID dir.
    # The *ScriptAliasMatch will match such requests because they look like
    # legitimate scm requests for a mysub vgrid, so we force redirection if
    # no matching mysub vgrid exists in the user-inaccessible vgrid_home dir.
    # We already prevent setting the executable bit on user home files so
    # fake cgi scripts would not work unless the user also found a way to
    # work around that limitation, but wsgi scripts need not be executable.
    # Thus, this guard is strictly required to protect against fake wsgi sub
    # vgrid components, and it will make cgi exploits harder, too.
    # We silently redirect any such bogus requests to the front page.
    RewriteCond %{REQUEST_URI} ^/([^/]+)/(vgrid_shared|private_base|public_base)/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$
    RewriteCond __MIG_STATE__/vgrid_home/%3 !-d
    RewriteRule ^/(.*) / [L,R]

    # Redirect to private file in vgrid
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/path/(.*) /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/path/.*
    RewriteRule ^/vgrid/(.*)/path/(.*) /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=$2 [L,R]
    # if the "path" is missing, go to top level:
    # (if there was one, the previous rewrite rule has transformed it)
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgrid/(.*)/$ /wsgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]
    RewriteCond %{REQUEST_URI} ^/vgrid/.*/$
    RewriteRule ^/vgrid/(.*)/$ /cgi-bin/showvgridprivatefile.py?vgrid_name=$1&path=index.html [L,R]

    # Redirect to member/owner scm in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridscm dir and
    # normal dirs in rewrite
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridscm
    RewriteRule ^/vgridscm/(.*) /cert_redirect/vgrid_shared/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to owner scm in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/wsgi-bin/hgweb.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownerscm
    RewriteRule ^/vgridownerscm/(.*) /cert_redirect/private_base/$1/.vgridscm/cgi-bin/hgweb.cgi [L,R]

    # Redirect to member/owner tracker in vgrid - we need to introduce a
    # vgrid_shared to be able to discriminate between vgridtracker dir and
    # normal dirs in rewrite.
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridtracker
    RewriteRule ^/vgridtracker/(.*) /cert_redirect/vgrid_shared/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect to owner tracker in vgrid
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/wsgi-bin/trac.wsgi [L,R]
    RewriteCond %{REQUEST_URI} ^/vgridownertracker
    RewriteRule ^/vgridownertracker/(.*) /cert_redirect/private_base/$1/.vgridtracker/cgi-bin/trac.cgi [L,R]

    # Redirect server status requests to /SERVER_NAME/SERVERNAME.status
    RewriteCond %{REQUEST_URI} ^/server_status
    RewriteRule ^/server_status /%{SERVER_NAME}/%{SERVER_NAME}.status [NE,L]

    ######################################################################
    ######################################################################

    # Redirect user GET file with cert_redirect in request to users home
    # dir.
    # Get the DN from the certificate of the user.
    #
    # Rewrite DN slightly to match the actual file system homes. I.e.
    # replace space with underscore and slash with plus in certificate DN.
    #
    # As an example we want /cert_redirect/PATH for the user with DN: 
    # /C=DK/ST=NA/L=NA/O=NBI/OU=NA/CN=Jonas Bardino/emailAddress=bardino@nbi.ku.dk
    # to be mapped to 
    # /+C=DK+ST=NA+L=NA+O=NBI+OU=NA+CN=Jonas_Bardino+emailAddress=bardino@nbi.ku.dk/PATH
    # 
    # Access is restricted with htaccess file in user homes so nothing to
    # worry about in relation to users spoofing rewrite targets.

    # Set up some escape and chroot checking helpers

    RewriteMap escape int:escape
    RewriteMap unescape int:unescape
    RewriteMap chkuserroot prg:__MIG_CODE__/server/chkuserroot.py

    # Careful to avoid breakage with exotic chars like percent in filenames. 
    # Fake certificate DN so that we can modify it further without PATH
    # interference. It may already be on final format but that doesn't hurt.
    # REMOTE_USER is only available in later stages so we must use 
    # LA-U:REMOTE_USER and it contains the full OpenID URL so we strip the
    # leading prefix until after the https://a.b.c/openid/id/ part.
    # We rename cert_redirect and finish with N(ext) rather than C(hain) to
    # avoid looping forever on the escape and delayed DN lookup rules. 

    RewriteCond %{REQUEST_URI} ^/cert_redirect/
    RewriteCond %{LA-U:REMOTE_USER} !^$
    RewriteRule ^/cert_redirect/(.*) /cert_mangle/${escape:$1} [C]
    RewriteRule ^/cert_mangle/(.*) /strip_provider/%{LA-U:REMOTE_USER}/cert_mangle/$1 [NE,C]
    RewriteRule ^/strip_provider/__EXT_OID_PROVIDER_ID__/*(.+)/cert_mangle/(.*) $1/cert_mangle/$2 [NE,N]

    # Keep replacing space in DN with underscore
    
    RewriteRule ^(.*)\ (.*)/cert_mangle/(.*)$ $1_$2/cert_mangle/$3 [N]
    
    # Keep replacing slash in DN with plus
    
    RewriteRule ^(.*)/(.*)/cert_mangle/(.*)$ $1+$2/cert_mangle/$3 [N]

    # Finally remove certificate marker and unescape previously escaped path
    # IMPORTANT: all major browsers have trouble to some extent when accessing
    # the resulting cert_redirect data if we let the rules proceed as in the
    # cert case ([N]). This leads to subtle errors like IE and Chrome returning
    # an error instead of downloading e.g. PDF files when double clicking in
    # Files and FF not actually applying Settings -> style. Strangely enough
    # FF succeeds in the former and Chrome+IE in the latter case.
    # We explicitly SSL proxy ([P]) to work around the issues.

    # NOTE: we proxy here to make sure we only target cert mangled paths.
    # It does NOT mean that we skip chroot check below as that will still
    # happen in the new request caused by the proxy'ing.
    RewriteRule ^(.+)/cert_mangle/(.*)$ /$1/${unescape:$2} [P]

    # Prevent e.g. symlinks escaping user chroots once past cert mangling.
    # Apache starts chkuserroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond %{REQUEST_URI} !^/proxy$
    RewriteCond %{REQUEST_FILENAME} !^/cert_redirect/.*$
    RewriteCond %{REQUEST_FILENAME} !^/cert_mangle/.*$
    RewriteCond ${chkuserroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]

    ######################################################################
    ######################################################################
    
    # We need to let vgrid wiki cgi requests pass through to *ScriptAlias*
    # handlers.
    # NB: first regex group *must* match DNs only - not '.*'!
    RewriteRule ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/private_base/$2/$3/$4/$5 [L,PT]
    RewriteRule ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/([^/]+-bin)/(.*)$ /$1/vgrid_shared/$2/$3/$4/$5 [L,PT]

    #######################################################################
    # IMPORTANT: Never allow users writing in these cgi-bin's in any way! #
    # It would leave a remote execution hole open for all VGrid members.  #
    #######################################################################

    # Public vgrid component access (disabled for now to avoid abuse)
    #ScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/cgi-bin/$3
    # Home directory vgrid component access - we need to avoid catching raw
    # cert_redirect URLs
    ScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/user_home/$1/private_base/$2/$3/cgi-bin/$4
    ScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/cgi-bin/(.*) __MIG_STATE__/user_home/$1/$2/$3/cgi-bin/$4
    <IfModule mod_wsgi.c>
        # Public vgrid component access (disabled for now to avoid abuse)
        #WSGIScriptAliasMatch ^/vgrid/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/wwwpublic/$1/$2/wsgi-bin/$3
        WSGIScriptAliasMatch ^/([^/]+)/private_base/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/user_home/$1/private_base/$2/$3/wsgi-bin/$4
        WSGIScriptAliasMatch ^/([^/]+)/vgrid_shared/(.*)/(.vgrid[^/]+)/wsgi-bin/(.*) __MIG_STATE__/user_home/$1/$2/$3/wsgi-bin/$4
    </IfModule>

    ### Seafile (optional)
    
    # NOTE: seahub exposed here as well for sign-up integration without 
    #       XSS/CSRF prevention issues

    # Seafile media files - rely on symlink to latest install
    __SEAFILE_REMOTE_COMMENTED__ Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    __SEAFILE_COMMENTED__ <LocationMatch ^/(seafile|seafmedia|seafhttp)>
    __SEAFILE_COMMENTED__     <IfVersion > 2.2>
    __SEAFILE_COMMENTED__         <IfModule mod_access_compat.c>
    __SEAFILE_COMMENTED__             Order allow,deny
    __SEAFILE_COMMENTED__             Allow from all
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__         <IfModule !mod_access_compat.c>
    __SEAFILE_COMMENTED__             Require all granted
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__     <IfVersion <= 2.2>
    __SEAFILE_COMMENTED__         Order allow,deny
    __SEAFILE_COMMENTED__         Allow from all
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__ </LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    __SEAFILE_COMMENTED__ ProxyPass /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    __SEAFILE_COMMENTED__ SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    __SEAFILE_COMMENTED__ ProxyPass /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPass /seafmedia __SEAFMEDIA_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPassReverse /seafmedia __SEAFMEDIA_PROXY_URL__

    #
    # JupyterHub server
    #
    __JUPYTER_COMMENTED__ Include __APACHE_ETC__/conf.extras.d/MiG-jupyter-proxy.conf

    ### ParaViewWeb (optional

    # Have Apache pass these requests to the ParaViewWeb launcher
    __PREVIEW_COMMENTED__ ProxyPass /paraview http://localhost:8081/paraview

    # This is the path of the mapping file
    __PREVIEW_COMMENTED__ RewriteMap session-to-port txt:__MIG_STATE__/paraview_home/launcher/proxy.txt

    # This is the rewrite condition.
    # Look for anything with a sessionId=
    # in the query part of the URL and capture the value to use below.
    __PREVIEW_COMMENTED__ RewriteCond %{QUERY_STRING} ^sessionId=(.*)$ [NC]

    # This does the rewrite using the mapping file and the sessionId
    __PREVIEW_COMMENTED__ RewriteRule ^/proxy.*$  ws://${session-to-port:%1}/ws [P]

    __TWOFACTOR_COMMENTED__ <Directory /home/mig/mig/cgi-auth>
    __TWOFACTOR_COMMENTED__     AuthType OpenID
    __TWOFACTOR_COMMENTED__     <IfVersion > 2.2>
    __TWOFACTOR_COMMENTED__         <IfModule mod_access_compat.c>
    __TWOFACTOR_COMMENTED__             Order allow,deny
    __TWOFACTOR_COMMENTED__             Allow from all
    __TWOFACTOR_COMMENTED__         </IfModule>
    __TWOFACTOR_COMMENTED__         # NOTE: no entry for 2.4+ here since it disables auth
    __TWOFACTOR_COMMENTED__         #<IfModule !mod_access_compat.c>
    __TWOFACTOR_COMMENTED__         #    Require all granted 
    __TWOFACTOR_COMMENTED__         #</IfModule>
    __TWOFACTOR_COMMENTED__     </IfVersion>
    __TWOFACTOR_COMMENTED__     <IfVersion <= 2.2>
    __TWOFACTOR_COMMENTED__         Order allow,deny
    __TWOFACTOR_COMMENTED__         Allow from all
    __TWOFACTOR_COMMENTED__     </IfVersion>
    __TWOFACTOR_COMMENTED__     Require valid-user
    __TWOFACTOR_COMMENTED__ </Directory>

</VirtualHost>
</IfDefine>
</IfDefine>
</IfModule>

# Configure SSL with session-id virtual host
<IfDefine SID_FQDN>
<IfDefine SID_PORT>
# For job file access on resources and secure pages without certificate/OpenID
<VirtualHost ${SID_FQDN}:${SID_PORT}>
    # General setup for the virtual host
    ServerName ${SID_FQDN}
    DocumentRoot "__MIG_STATE__/webserver_home"
    ErrorLog __APACHE_LOG__/ssl-sid-error.log
    CustomLog __APACHE_LOG__/ssl-sid-access.log common

    # Optional per-vhost certificate setup for use with externally signed certs
    # IMPORTANT: we split CA setup to allow both client and server cert check.
    # We only override SSLCertificateChainFile *not* SSLCACertificateFile from
    # above. Thus clients can check server cert while we verify clients certs
    # against our own CA.
    __VHOSTCERTS_COMMENTED__ SSLCertificateFile __MIG_CERTS__/${SID_FQDN}/server.crt
    __VHOSTCERTS_COMMENTED__ SSLCertificateKeyFile __MIG_CERTS__/${SID_FQDN}/server.key
    __VHOSTCERTS_COMMENTED__ SSLCertificateChainFile __MIG_CERTS__/${SID_FQDN}/server.ca.pem

    ScriptAlias /cgi-sid/ "__MIG_CODE__/cgi-sid/"

    <IfModule mod_headers.c>
        # Use HSTS if enabled
        __HSTS_COMMENTED__ Header always set Strict-Transport-Security "max-age=31536000"
        # As a precaution apply proxy limit in line with security advisory on:
        # http://www.apache.org/security/asf-httpoxy-response.txt
        RequestHeader unset Proxy early
    </IfModule>

    <IfModule mod_wsgi.c>
        WSGIScriptAlias /wsgi-bin "__MIG_CODE__/wsgi-bin/migwsgi.py"
        # Optional software repository from grid.dk (partial checkout)
        WSGIScriptAlias /software-repository "__MIG_CODE__/software-repository/swrepo.py"
    </IfModule>

    #   SSL Engine Switch:
    #   Enable/Disable SSL for this virtual host.
    SSLEngine on

    # SSL options that depend on which virtual host is used
    #   Client Authentication (Type):
    #   Client certificate verification type and depth.  Types are
    #   none, optional, require and optional_no_ca.  Depth is a
    #   number which specifies how deeply to verify the certificate
    #   issuer chain before deciding the certificate is not valid.
    SSLVerifyClient none

    # Remote Seafile, OpenID, etc. requires SSL proxy
    __PROXY_HTTPS_COMMENTED__ SSLProxyEngine on

    ### Any special directories without auth requirement should go here...

    # Currently no such dirs except the globally configured ones at the top

    #### All other locations share basic conf and can use SSL envs

    <Directory "__MIG_BASE__/">
        # Pass SSL variables on
        SSLOptions +StdEnvVars
    </Directory>

    ### The rest are sub-dirs that inherit the general conf above and
    ### they can override any settings explicitly

    # WSGI interface (only visible if mod_wsgi is loaded)
    <Directory "__MIG_CODE__/wsgi-bin">
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    <Directory "__MIG_CODE__/cgi-sid">
        Options +ExecCGI
        # Remove source address based access limitations here
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # SID access from resources
    Alias /sid_redirect/ "__MIG_STATE__/webserver_home/"
    <Directory "__MIG_STATE__/webserver_home/">
        # Remove source address based access limitations here
        # Access is restricted by long random hashed session IDs
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Allow from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all granted 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Allow from all
        </IfVersion>
    </Directory>
    # Low level share link file access from e.g. external users
    # High level file management goes through cgi-sid
    # Please refer to the notes in shared.sharelinks for sharelink ID details
    AliasMatch "^/share_redirect/([a-hA-H].*)" "__MIG_STATE__/sharelink_home/read-only/$1"
    AliasMatch "^/share_redirect/([i-pI-P].*)" "__MIG_STATE__/sharelink_home/read-write/$1"
    AliasMatch "^/share_redirect/([q-xQ-X].*)" "__MIG_STATE__/sharelink_home/write-only/$1"
    <Directory "__MIG_STATE__/sharelink_home">
        # Don't allow direct access here, only in sub directories
        <IfVersion > 2.2>
            <IfModule mod_access_compat.c>
                Order allow,deny
                Deny from all
            </IfModule>
            <IfModule !mod_access_compat.c>
                Require all denied 
            </IfModule>
        </IfVersion>
        <IfVersion <= 2.2>
            Order allow,deny
            Deny from all
        </IfVersion>
    </Directory>
    <IfModule mod_actions.c>
    <Directory "__MIG_STATE__/sharelink_home/read-only">
        # Remove source address based access limits for allowed methods
        # Access is additionally restricted by long random hashed session IDs
        <Limit GET>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Allow from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all granted 
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Allow from all
            </IfVersion>
        </LIMIT>
        <LimitExcept GET>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Deny from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all denied 
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Deny from all
            </IfVersion>
        </LimitExcept>
    </Directory>
    <Directory "__MIG_STATE__/sharelink_home/write-only">
        # Remove source address based access limits for allowed methods
        # Access is additionally restricted by long random hashed session IDs
        <Limit PUT SHAREPUT>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Allow from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all granted 
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Allow from all
            </IfVersion>
        </LIMIT>
        <LimitExcept PUT SHAREPUT>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Deny from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all denied 
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Deny from all
            </IfVersion>
        </LimitExcept>
        Script PUT /cgi-sid/put
        Script SHAREPUT /cgi-sid/put
    </Directory>
    <Directory "__MIG_STATE__/sharelink_home/read-write">
        # Remove source address based access limits for allowed methods
        # Access is additionally restricted by long random hashed session IDs
        <Limit GET PUT SHAREPUT>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Allow from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all granted 
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Allow from all
            </IfVersion>
        </LIMIT>
        <LimitExcept GET PUT SHAREPUT>
            <IfVersion > 2.2>
                <IfModule mod_access_compat.c>
                    Order allow,deny
                    Deny from all
                </IfModule>
                <IfModule !mod_access_compat.c>
                    Require all denied 
                </IfModule>
            </IfVersion>
            <IfVersion <= 2.2>
                Order allow,deny
                Deny from all
            </IfVersion>
        </LimitExcept>
        Script PUT /cgi-sid/put
        Script SHAREPUT /cgi-sid/put
    </Directory>
    </IfModule>

    # Rewriting
    RewriteEngine on
    # Notice: Using a high value for RewriteLogLevel will slow down your
    # Apache server dramatically! 
    # Only use a rewrite loglevel greater than (trace)2 for debugging!
    # These were replaced by the general logger in apache>=2.4
    <IfVersion >= 2.4>
        LogLevel notice rewrite:info
    </IfVersion>
    <IfVersion < 2.4>
        RewriteLog __APACHE_LOG__/ssl-sid-rewrite.log
        RewriteLogLevel 0
    </IfVersion>

    # Prevent trace and track requests from leaking information
    RewriteCond %{REQUEST_METHOD} ^(TRACE|TRACK)
    RewriteRule .* - [F]

    # Make sure trailing slash in seafile client conf doesn't cause problems
    # by silently passing through request to the single slash version.
    __SEAFILE_COMMENTED__ RewriteCond %{REQUEST_URI} ^/seafile//.*$
    __SEAFILE_COMMENTED__ RewriteRule ^/seafile//(.*)$ /seafile/$1 [PT]

    # Break rewriting chain for commonly-requested final destinations
    # * Direct files (including subrequest for /X.py from /wsgi-bin/X.py)
    # * Xgi scripts
    # * Internal Aliased helper locations
    # * External Aliased helper locations
    RewriteCond %{QUERY_STRING} ^$
    RewriteCond %{REQUEST_URI} ^/[^/]*$
    RewriteRule ^ - [L]

    RewriteCond %{REQUEST_URI} ^/(wsgi-bin|cgi-bin|cgi-sid|cgi-cert)/ [OR]
    RewriteCond %{REQUEST_URI} ^/favicon.ico$ [OR]
    RewriteCond %{REQUEST_URI} ^/(images|assets|public)/ [OR]
    RewriteCond %{REQUEST_URI} ^/(seafmedia|seafhttp|seafile)/ [OR]
    RewriteCond %{REQUEST_URI} ^/paraview/
    RewriteRule ^ - [L]

    # Stay on wsgi-bin if user comes from that already, otherwise use cgi-sid
    RewriteCond %{REQUEST_URI} ^/sharelink/.*$
    RewriteCond %{HTTP_REFERER} /wsgi-bin/
    RewriteRule ^/sharelink/(.*)$ /wsgi-bin/ls.py?share_id=$1 [L,R]
    RewriteCond %{REQUEST_URI} ^/sharelink/.*$
    RewriteRule ^/sharelink/(.*)$ /cgi-sid/ls.py?share_id=$1 [L,R]

    # Set up chroot checking helper
    
    RewriteMap chksidroot prg:__MIG_CODE__/server/chksidroot.py

    # Prevent e.g. symlinks escaping user chroots hidden behind session or
    # sharelink symlinks.
    # Apache starts chksidroot prg as a shared daemon for all requests from this
    # vhost. Requests are passed to the daemon on stdin, one line at a time and
    # apache then reads corresponding response back from stdout, which we can
    # then use to rewrite. Thus it is essential that daemon doesn't block or
    # stall, as it is a bottleneck for all further requests.
    # The daemon prints the actual expanded path if it is inside the valid
    # chroots and for all other paths it prints _OUT_OF_BOUNDS_ , so we use
    # that as a failure marker and then force access forbidden.
    RewriteCond ${chksidroot:%{REMOTE_ADDR}::%{DOCUMENT_ROOT}%{REQUEST_FILENAME}} ^_OUT_OF_BOUNDS_$
    RewriteRule .* - [F]

    ### Seafile (optional)

    # Seafile media files - rely on symlink to latest install
    __SEAFILE_REMOTE_COMMENTED__ Alias /seafmedia /home/mig/seafile/seafile-server-latest/seahub/media
    __SEAFILE_COMMENTED__ <LocationMatch ^/(seafile|seafmedia|seafhttp)>
    __SEAFILE_COMMENTED__     <IfVersion > 2.2>
    __SEAFILE_COMMENTED__         <IfModule mod_access_compat.c>
    __SEAFILE_COMMENTED__             Order allow,deny
    __SEAFILE_COMMENTED__             Allow from all
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__         <IfModule !mod_access_compat.c>
    __SEAFILE_COMMENTED__             Require all granted
    __SEAFILE_COMMENTED__         </IfModule>
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__     <IfVersion <= 2.2>
    __SEAFILE_COMMENTED__         Order allow,deny
    __SEAFILE_COMMENTED__         Allow from all
    __SEAFILE_COMMENTED__     </IfVersion>
    __SEAFILE_COMMENTED__ </LocationMatch>

    # Expose seafile/seahub with implicit  wsgi instead of fastcgi since 6.2

    #
    # Seafile file server
    #
    __SEAFILE_COMMENTED__ ProxyPass /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafhttp __SEAFHTTP_PROXY_URL__
    __SEAFILE_COMMENTED__ RewriteRule ^/seafhttp - [QSA,L]
    
    #
    # Seahub web interface
    #
    __SEAFILE_COMMENTED__ SetEnvIf Authorization "(.*)" HTTP_AUTHORIZATION=$1
    __SEAFILE_COMMENTED__ ProxyPass /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_COMMENTED__ ProxyPassReverse /seafile __SEAFILE_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPass /seafmedia __SEAFMEDIA_PROXY_URL__
    __SEAFILE_LOCAL_COMMENTED__ ProxyPassReverse /seafmedia __SEAFMEDIA_PROXY_URL__
</VirtualHost>
</IfDefine>
</IfDefine>
