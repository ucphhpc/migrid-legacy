#!/usr/bin/python

"""Apache handler of the same name which allows direct access to
this function just like GET and PUT."""

import cgi
import cgitb; cgitb.enable()
import os
import sys

# MiG imports
from shared.cgishared import init_cgiscript_possibly_with_cert
from shared.handlers import correct_handler, get_path, \
     get_allowed_path
import shared.localos as localos

# TODO: only output relative paths!

### Main ###
handler_name = os.path.basename(sys.argv[0]).upper()

(logger, configuration, cert_name_no_spaces, o) = init_cgiscript_possibly_with_cert()

# Check we are using matching method
if not correct_handler(handler_name):
    # Request method does not match handler
    o.out("You must use HTTP %s!" % handler_name)
    o.reply_and_exit(o.CLIENT_ERROR)

# Check we got a target filename
path = get_path()
if not path:
    o.out("Target filename not found - did you specify one?")
    o.reply_and_exit(o.CLIENT_ERROR)

try:
    target_path = get_allowed_path(configuration, cert_name_no_spaces,
                               path)
except Exception, err:
    # invalid certificate or session id - deny access!
    o.out("Certificate and Session ID verification failed! (%s)" % \
          cert_name_no_spaces)
    o.internal("Entity with cert data '%s' was rejected when trying to use http %s %s: %s" % (cert_name_no_spaces, handler_name, path, err))
    o.reply_and_exit(o.ERROR)

# Now handle actual file (shared for for all situations)
try:
    localos.mkdir(target_path)
except Exception, err:
    filtered_err = str(err).replace(target_path, path)
    o.out("Could not %s %s: %s" % (handler_name, path, filtered_err))
    o.reply_and_exit(o.CLIENT_ERROR)

# if we get here everything was ok
o.reply_and_exit(o.OK)
